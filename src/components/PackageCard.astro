---
const { title, price, features } = Astro.props;
---

<div class="pricing-card rounded-lg overflow-hidden shadow-md bg-background/70">
  <div class="text-center custom-shape pt-5 pb-14 stage">
    <h2 class="text-xl font-bold mb-4">{title}</h2>
    <div class="flex justify-center items-center">
      <span
        class="price-text !text-4xl font-semibold block txt cursor-pointer select-none"
        >${price}</span
      >
      <span class="font-light text-2xl">&nbsp;/ month</span>
    </div>
  </div>

  <div class="p-6">
    <ul class="list-none flex flex-col">
      {
        features.map((feature, idx) => (
          <li
            class={`leading-relaxed flex items-center justify-center py-3 text-center ${idx === 0 ? "" : "border-t border-primary/10"}`}
          >
            <span>{feature}</span>
          </li>
        ))
      }
    </ul>
  </div>
</div>

<script is:inline>
  window.addEventListener("DOMContentLoaded", () => {
    if (window.innerWidth > 768) {
      if (document.fonts && document.fonts.status === "loaded") {
        document.fonts.ready.then(initAnimation);
      } else {
        initAnimation();
      }
    }
  });

  const initAnimation = () => {
    document.querySelectorAll(".price-text").forEach((priceEl) => {
      let split = new SplitText(priceEl, {
        type: "chars",
        charsClass: "char",
        position: "relative",
      });

      const chars = priceEl.querySelectorAll(".char");
      const charH = priceEl.offsetHeight;
      const weightInit = 600;
      const weightTarget = 400;
      const weightDiff = weightInit - weightTarget;
      const stretchInit = 150;
      const stretchTarget = 80;
      const stretchDiff = stretchInit - stretchTarget;
      const maxYScale = 2.5;
      let numChars = chars.length;
      let isMouseDown = false;
      let mouseInitialY = 0;
      let mouseFinalY = 0;
      let distY = 0;
      let charIndexSelected = 0;
      let elasticDropOff = 0.8;
      let dragYScale = 0;

      function animInTxt() {
        let elem = chars[0];
        let rect = elem.getBoundingClientRect();
        gsap.from(chars, {
          // y: () => -1 * (rect.y + charH + 500),
          fontWeight: weightTarget * 2,
          fontStretch: stretchTarget,
          scaleY: 0.005,
          ease: "elastic(0.2, 0.1)",
          duration: 1.5,
          delay: 0.5,
          stagger: {
            each: 0.05,
            from: "random",
          },
          onComplete: initEvents,
        });
      }
      function calcDist() {
        let maxYDragDist = charH * (maxYScale - 1);
        distY = mouseInitialY - mouseFinalY;
        dragYScale = distY / maxYDragDist;
        if (dragYScale > maxYScale - 1) {
          dragYScale = maxYScale - 1;
        } else if (dragYScale < -0.5) {
          dragYScale = -0.5;
        }
      }

      function setFontDragDimensions() {
        gsap.to(chars, {
          y: (index) => {
            let fracDispersion = calcfracDispersion(index);
            return fracDispersion * -2;
          },
          fontWeight: (index) => {
            let fracDispersion = calcfracDispersion(index);
            return weightInit - fracDispersion * weightDiff;
          },
          fontStretch: (index) => {
            let fracDispersion = calcfracDispersion(index);
            return stretchInit - fracDispersion * stretchDiff;
          },
          scaleY: (index) => {
            let fracDispersion = calcfracDispersion(index);
            let scaleY = 1 + fracDispersion;
            if (scaleY < 0.5) scaleY = 0.5;
            return scaleY;
          },
          ease: "power4",
          duration: 0.6,
        });
      }

      function calcfracDispersion(index) {
        let dispersion =
          1 - Math.abs(index - charIndexSelected) / (numChars * elasticDropOff);
        return dispersion * dragYScale;
      }

      function snapBackText() {
        gsap.to(chars, {
          y: 0,
          fontWeight: weightInit,
          fontStretch: stretchInit,
          scale: 1,
          ease: "elastic(0.35, 0.1)",
          duration: 1,
          stagger: {
            each: 0.02,
            from: charIndexSelected,
          },
        });
      }

      function initEvents() {
        const onMouseUp = (e) => {
          if (isMouseDown) {
            mouseFinalY = e.clientY;
            isMouseDown = false;
            snapBackText();
            document.body.classList.remove("grab");
          }
        };
        const onMouseMove = (e) => {
          if (isMouseDown) {
            mouseFinalY = e.clientY;
            calcDist();
            setFontDragDimensions();
          }
        };
        const onMouseLeave = (event) => {
          if (
            event.clientY <= 0 ||
            event.clientX <= 0 ||
            event.clientX >= window.innerWidth ||
            event.clientY >= window.innerHeight
          ) {
            snapBackText();
            isMouseDown = false;
          }
        };
        document.body.addEventListener("mouseup", onMouseUp);
        document.body.addEventListener("mousemove", onMouseMove);
        document.body.addEventListener("mouseleave", onMouseLeave);
        chars.forEach((char, index) => {
          char.addEventListener("mousedown", function (e) {
            mouseInitialY = e.clientY;
            charIndexSelected = index;
            isMouseDown = true;
            document.body.classList.add("grab");
          });
        });
        // Cleanup
        return () => {
          document.body.removeEventListener("mouseup", onMouseUp);
          document.body.removeEventListener("mousemove", onMouseMove);
          document.body.removeEventListener("mouseleave", onMouseLeave);
        };
      }

      animInTxt();
    });
  };
</script>
